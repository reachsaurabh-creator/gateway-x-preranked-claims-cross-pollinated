<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FINAL WORKING TEST</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-section { margin: 20px 0; padding: 20px; border: 1px solid #ccc; border-radius: 8px; }
        .chart-container { margin: 2rem 0; padding: 1rem; background: #f8fafc; border-radius: 8px; }
        .chart-title { font-weight: 600; margin-bottom: 1rem; text-align: center; }
        .chart { width: 100%; height: 200px; border: 2px solid #e2e8f0; background: #ffffff; }
        .rounds-container { margin-top: 2rem; }
        .round-toggle { 
            width: 100%; 
            background: #f8fafc; 
            border: 1px solid #e2e8f0; 
            border-radius: 8px; 
            padding: 1rem; 
            margin-bottom: 0.5rem; 
            cursor: pointer; 
            transition: all 0.2s; 
            text-align: left; 
            position: relative; 
        }
        .round-toggle:hover { background: #e2e8f0; }
        .round-toggle.active { background: #2563eb; color: white; border-color: #2563eb; }
        .round-toggle::after { 
            content: '‚ñº'; 
            position: absolute; 
            right: 1rem; 
            top: 50%; 
            transform: translateY(-50%); 
            transition: transform 0.2s; 
        }
        .round-toggle.active::after { transform: translateY(-50%) rotate(180deg); }
        .round-header { display: flex; justify-content: space-between; align-items: center; font-weight: 600; }
        .round-details { 
            display: none; 
            margin-top: 1rem; 
            padding-top: 1rem; 
            border-top: 1px solid #e2e8f0; 
            background: #ffffff;
            padding: 1rem;
            border-radius: 6px;
            margin: 1rem 0;
        }
        .model-response { 
            background: #f8f9fa; 
            border: 1px solid #e2e8f0; 
            border-radius: 6px; 
            padding: 1rem; 
            margin-bottom: 1rem; 
        }
        .model-name { font-weight: 600; margin-bottom: 0.5rem; color: #2563eb; }
        .success { color: green; font-weight: bold; }
        .error { color: red; font-weight: bold; }
        .results { display: block; }
    </style>
</head>
<body>
    <h1>üéØ FINAL WORKING TEST - BULLETPROOF ROUND DETAILS</h1>
    
    <div class="test-section">
        <h3>Test Status:</h3>
        <button onclick="testComplete()" style="padding: 10px 20px; font-size: 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">üöÄ TEST COMPLETE FRONTEND</button>
        <div id="test-result"></div>
    </div>
    
    <div class="results" id="resultsSection">
        <div class="chart-container">
            <div class="chart-title">Consensus Convergence Over Rounds</div>
            <canvas class="chart" id="convergenceChart"></canvas>
            <div id="chart-info"></div>
        </div>
        
        <div class="test-section">
            <h3>Round Details (BULLETPROOF VERSION):</h3>
            <div class="rounds-container" id="roundsContainer"></div>
        </div>
    </div>

    <script>
        let currentOpenRound = null;
        
        async function testComplete() {
            try {
                console.log('üöÄ Testing complete frontend with bulletproof approach...');
                
                // Get real timeline data
                const timelineResponse = await fetch('/timeline/9aef4f1ca7a2');
                if (!timelineResponse.ok) {
                    throw new Error('Failed to fetch timeline data');
                }
                
                const timelineData = await timelineResponse.json();
                console.log('‚úÖ Timeline data received:', timelineData);
                
                // Show results section first
                document.getElementById('resultsSection').style.display = 'block';
                
                // Draw the chart
                drawConvergenceChart(timelineData);
                
                // Display round details
                displayRoundDetails(timelineData);
                
                document.getElementById('test-result').innerHTML = `
                    <div class="success">
                        ‚úÖ SUCCESS! Loaded ${timelineData.length} rounds of data<br>
                        ‚úÖ Chart drawn successfully<br>
                        ‚úÖ Round details displayed with bulletproof approach<br>
                        ‚úÖ First round auto-expanded and PERSISTENT<br>
                        ‚úÖ Click any round to expand/collapse - CONTENT STAYS VISIBLE!
                    </div>
                `;
                
            } catch (error) {
                console.error('‚ùå Error:', error);
                document.getElementById('test-result').innerHTML = `
                    <div class="error">‚ùå ERROR: ${error.message}</div>
                `;
            }
        }
        
        function drawConvergenceChart(timeline) {
            console.log('üìä Drawing convergence chart...');
            
            const canvas = document.getElementById('convergenceChart');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size
            const containerWidth = canvas.parentElement.offsetWidth;
            canvas.width = containerWidth - 32;
            canvas.height = 200;
            
            const width = canvas.width;
            const height = canvas.height;
            const padding = 40;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            if (timeline.length === 0) {
                console.log('No timeline data for chart');
                return;
            }
            
            // Extract convergence scores
            const scores = timeline.map(round => round.convergence_score);
            console.log('Convergence scores:', scores);
            
            // Draw background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, width, height);
            
            // Draw axes
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;
            
            // Y-axis
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.stroke();
            
            // X-axis
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            // Draw grid lines and labels
            ctx.fillStyle = '#64748b';
            ctx.font = '12px Arial';
            
            // Y-axis labels
            for (let i = 0; i <= 10; i++) {
                const y = height - padding - (i / 10) * (height - 2 * padding);
                const value = (i * 10) + '%';
                ctx.fillText(value, 5, y + 4);
                
                if (i > 0) {
                    ctx.strokeStyle = '#f1f5f9';
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(width - padding, y);
                    ctx.stroke();
                }
            }
            
            // X-axis labels
            for (let i = 0; i < timeline.length; i++) {
                const x = padding + (i / Math.max(timeline.length - 1, 1)) * (width - 2 * padding);
                ctx.fillText(`R${i + 1}`, x - 10, height - 10);
            }
            
            // Draw convergence line
            if (timeline.length > 1) {
                ctx.strokeStyle = '#2563eb';
                ctx.lineWidth = 3;
                ctx.beginPath();
                
                for (let i = 0; i < timeline.length; i++) {
                    const x = padding + (i / Math.max(timeline.length - 1, 1)) * (width - 2 * padding);
                    const y = height - padding - (scores[i]) * (height - 2 * padding);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
                
                // Draw points
                ctx.fillStyle = '#2563eb';
                for (let i = 0; i < timeline.length; i++) {
                    const x = padding + (i / Math.max(timeline.length - 1, 1)) * (width - 2 * padding);
                    const y = height - padding - (scores[i]) * (height - 2 * padding);
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                }
            } else {
                // Single point
                const x = padding + (width - 2 * padding) / 2;
                const y = height - padding - (scores[0]) * (height - 2 * padding);
                
                ctx.fillStyle = '#2563eb';
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            document.getElementById('chart-info').innerHTML = `
                <div class="success" style="margin-top: 10px;">
                    ‚úÖ Chart drawn successfully!<br>
                    Timeline length: ${timeline.length}<br>
                    Scores: ${scores.map(s => s.toFixed(3)).join(', ')}
                </div>
            `;
        }
        
        function displayRoundDetails(timeline) {
            console.log('üìã Displaying round details with bulletproof approach...');
            const container = document.getElementById('roundsContainer');
            container.innerHTML = '';
            
            timeline.forEach((round, index) => {
                console.log(`Processing round ${index + 1}:`, round);
                
                const roundDiv = document.createElement('div');
                roundDiv.className = 'round-toggle';
                roundDiv.onclick = () => toggleRound(index);
                
                const confidence = (round.convergence_score * 100).toFixed(1);
                
                roundDiv.innerHTML = `
                    <div class="round-header">
                        <span>Round ${round.round_index}</span>
                        <span class="confidence-badge">${confidence}% confidence</span>
                    </div>
                    <div class="round-details" id="round-${index}">
                        <div class="model-response">
                            <div class="model-name">Best Claim</div>
                            <div>${round.best_claim_text || 'No claim selected'}</div>
                        </div>
                        <div class="model-response">
                            <div class="model-name">Round Summary</div>
                            <div>${round.summary || 'No summary available'}</div>
                        </div>
                        <div class="model-response">
                            <div class="model-name">Top Claims</div>
                            ${round.top_claims ? round.top_claims.map(claim => `
                                <div style="margin-bottom: 0.5rem;">
                                    <strong>${claim.cid}:</strong> Score ${(claim.score * 100).toFixed(1)}%
                                    (CI: ${(claim.ci_low * 100).toFixed(1)}% - ${(claim.ci_high * 100).toFixed(1)}%)
                                </div>
                            `).join('') : 'No claims available'}
                        </div>
                    </div>
                `;
                
                container.appendChild(roundDiv);
                
                // Auto-expand the first round using bulletproof approach
                if (index === 0) {
                    setTimeout(() => {
                        const roundDetails = document.getElementById(`round-${index}`);
                        const roundToggle = roundDetails.parentElement;
                        if (roundDetails && roundToggle) {
                            roundDetails.style.display = 'block';
                            roundToggle.classList.add('active');
                            currentOpenRound = 0;
                            console.log('‚úÖ First round auto-opened and will stay visible');
                        }
                    }, 100);
                }
            });
        }
        
        function toggleRound(index) {
            const roundDetails = document.getElementById(`round-${index}`);
            const roundToggle = roundDetails.parentElement;
            
            console.log(`üîÑ Toggling round ${index}, current open: ${currentOpenRound}`);
            
            // If this round is already open, close it
            if (currentOpenRound === index) {
                roundDetails.style.display = 'none';
                roundToggle.classList.remove('active');
                currentOpenRound = null;
                console.log(`‚úÖ Closed round ${index}`);
                return;
            }
            
            // Close any currently open round
            if (currentOpenRound !== null) {
                const currentDetails = document.getElementById(`round-${currentOpenRound}`);
                const currentToggle = currentDetails.parentElement;
                currentDetails.style.display = 'none';
                currentToggle.classList.remove('active');
            }
            
            // Open the selected round
            roundDetails.style.display = 'block';
            roundToggle.classList.add('active');
            currentOpenRound = index;
            
            console.log(`‚úÖ Opened round ${index} - CONTENT WILL STAY VISIBLE!`);
        }
    </script>
</body>
</html>


